---
phase: 03-download-deploy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/download.ts
  - src/components/App.tsx
  - src/components/ImageCard.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can click Download All and receive a ZIP file containing all processed images with _nobg suffix filenames"
    - "User can click a download button on an individual image card to download that single processed image"
    - "ZIP generation processes 100 images sequentially without OOM or tab crash"
    - "Browser shows a native 'leave site?' dialog when user tries to close tab while processing is active or results are undownloaded"
    - "Duplicate original filenames produce unique ZIP entries (numeric suffix)"
  artifacts:
    - path: "src/lib/download.ts"
      provides: "ZIP generation, individual download, filename helpers, deduplication"
      exports: ["generateBatchZip", "downloadSingleImage", "getOutputFilename"]
    - path: "src/components/App.tsx"
      provides: "Download All button, useNavigationWarning hook, hasDownloaded tracking"
    - path: "src/components/ImageCard.tsx"
      provides: "Per-card download button for done images"
  key_links:
    - from: "src/components/App.tsx"
      to: "src/lib/download.ts"
      via: "generateBatchZip import, triggerDownload for ZIP blob"
      pattern: "generateBatchZip|downloadSingleImage"
    - from: "src/components/ImageCard.tsx"
      to: "src/lib/download.ts"
      via: "downloadSingleImage import for per-image download"
      pattern: "downloadSingleImage"
    - from: "src/components/App.tsx"
      to: "window.addEventListener.*beforeunload"
      via: "useNavigationWarning hook conditional on isProcessing || !hasDownloaded"
      pattern: "beforeunload"
---

<objective>
Implement batch ZIP download (fflate streaming), individual image download, filename preservation with _nobg suffix, duplicate deduplication, and navigation warning guard.

Purpose: This is the core deliverable of Phase 3 -- users need to get their processed images out of the browser. Without download, the entire processing pipeline has no output.
Output: `src/lib/download.ts` with all download logic, updated App.tsx with Download All button + navigation guard, updated ImageCard.tsx with per-image download button.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-download-deploy/03-RESEARCH.md
@.planning/phases/02-batch-ui/02-01-SUMMARY.md
@.planning/phases/02-batch-ui/02-02-SUMMARY.md
@src/lib/types.ts
@src/components/App.tsx
@src/components/ImageCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Download library + fflate ZIP generation</name>
  <files>src/lib/download.ts, package.json</files>
  <action>
Install fflate: `npm install fflate`

Create `src/lib/download.ts` with these exports:

1. **`getOutputFilename(originalName: string, mode: BackgroundMode): string`**
   - Strips original extension, appends `_nobg` + new extension
   - `mode === "transparent"` -> `.png`, `mode === "white"` -> `.jpg`
   - Example: `"photo.jpg"` + `"transparent"` -> `"photo_nobg.png"`

2. **`deduplicateNames(names: string[]): string[]`**
   - Tracks seen names with a `Map<string, number>`
   - First occurrence keeps original name, subsequent get `_2`, `_3` etc. inserted before extension
   - Example: `["a_nobg.png", "a_nobg.png"]` -> `["a_nobg.png", "a_nobg_2.png"]`

3. **`generateBatchZip(images: ImageItem[], mode: BackgroundMode, onProgress?: (current: number, total: number) => void): Promise<Blob>`**
   - Filter to only `status === "done"` images
   - Map each image to its blob URL (transparent -> `resultUrl`, white -> `resultWhiteUrl`)
   - Generate deduplicated output filenames via `getOutputFilename` + `deduplicateNames`
   - Create `new Zip()` from fflate with `ondata` callback collecting `Uint8Array` chunks into an array
   - Loop sequentially (NOT Promise.all) over images: `fetch(blobUrl)` -> `.arrayBuffer()` -> `new Uint8Array()`
   - For each: create `new ZipPassThrough(filename)`, `zip.add(entry)`, `entry.push(data, true)`
   - Call `onProgress?.(i + 1, total)` after each file
   - Call `zip.end()` after loop
   - Return `new Blob(chunks, { type: "application/zip" })`

4. **`triggerDownload(blob: Blob, filename: string): void`**
   - Create temp anchor element, set href to `URL.createObjectURL(blob)`, set download attribute
   - Append to body, click, then `setTimeout(() => { removeChild; revokeObjectURL }, 100)`

5. **`downloadSingleImage(blobUrl: string, originalName: string, mode: BackgroundMode): void`**
   - Create anchor with `href = blobUrl`, `download = getOutputFilename(originalName, mode)`
   - Append, click, remove -- do NOT revoke URL (still needed for preview)

Import types: `import type { ImageItem, BackgroundMode } from "./types"`
Import fflate: `import { Zip, ZipPassThrough } from "fflate"`
  </action>
  <verify>
- `npx tsc -b` compiles with zero errors
- `npm run build` succeeds
- `src/lib/download.ts` exists and exports all 5 functions
  </verify>
  <done>download.ts contains generateBatchZip with streaming fflate Zip + ZipPassThrough, downloadSingleImage, getOutputFilename, deduplicateNames, and triggerDownload. fflate is in package.json dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Wire download UI + navigation warning into App and ImageCard</name>
  <files>src/components/App.tsx, src/components/ImageCard.tsx</files>
  <action>
**In App.tsx:**

1. Add `useNavigationWarning` hook (inline in App.tsx or as a custom hook at top of file):
   - Accepts `shouldWarn: boolean`
   - `useEffect` that adds `beforeunload` listener when `shouldWarn` is true
   - Handler calls `e.preventDefault()` AND sets `e.returnValue = true` (legacy Chrome/Edge)
   - Cleanup removes listener

2. Add `hasDownloaded` state: `const [hasDownloaded, setHasDownloaded] = useState(false)`
   - Reset to `false` whenever new images are added (in `handleFilesAccepted`, after dispatch)
   - Set to `true` when Download All is clicked (after ZIP generation completes)

3. Wire `useNavigationWarning`:
   - `const isProcessing = state.images.some(i => i.status === "processing" || i.status === "queued")`
   - `const hasUndownloaded = doneCount > 0 && !hasDownloaded`
   - `useNavigationWarning(isProcessing || hasUndownloaded)`

4. Add `zipProgress` state: `const [zipProgress, setZipProgress] = useState<{ current: number; total: number } | null>(null)`

5. Add `handleDownloadAll` async handler:
   - Set `zipProgress` to `{ current: 0, total: doneCount }`
   - Call `generateBatchZip(state.images, state.backgroundMode, (current, total) => setZipProgress({ current, total }))`
   - Call `triggerDownload(blob, "batchclear-results.zip")`
   - Set `zipProgress(null)`, `setHasDownloaded(true)`
   - Wrap in try/catch, clear zipProgress on error

6. Add `handleDownloadSingle` callback passed to ImageGrid:
   - `(image: ImageItem) => downloadSingleImage(blobUrl, image.name, state.backgroundMode)` where blobUrl picks resultUrl or resultWhiteUrl based on backgroundMode

7. Render "Download All" button in the batch progress area (next to "Clear all"):
   - Only show when `doneCount > 0`
   - Disabled when `zipProgress !== null`
   - Button text: `zipProgress ? "Generating ZIP... ${zipProgress.current}/${zipProgress.total}" : "Download All (ZIP)"`
   - Style: primary blue/indigo button matching the app aesthetic
   - SVG download icon (arrow pointing down into tray)

8. Import `generateBatchZip`, `triggerDownload`, `downloadSingleImage` from `../lib/download`

**In ImageCard.tsx:**

1. Add `onDownload` prop: `onDownload?: (image: ImageItem) => void`
2. When `image.status === "done"`, render a download icon button in the bottom bar (between the status badge and the remove button)
3. Style: small icon button matching existing remove button style, with a download arrow SVG
4. aria-label: `Download ${image.name}`

**In ImageGrid.tsx:**

1. Add `onDownload` prop threading: accept `onDownload?: (image: ImageItem) => void` and pass it to each ImageCard
  </action>
  <verify>
- `npx tsc -b` compiles with zero errors
- `npm run build` succeeds
- App.tsx contains `beforeunload`, `generateBatchZip`, `Download All`
- ImageCard.tsx contains `onDownload` prop and download button
  </verify>
  <done>
Download All button appears when images are processed, shows ZIP generation progress, triggers file download. Each done ImageCard has a download button. Navigation warning fires when processing is active or results are undownloaded. hasDownloaded resets when new images are added.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b` -- zero TypeScript errors
2. `npm run build` -- production build succeeds
3. `src/lib/download.ts` exports generateBatchZip, downloadSingleImage, getOutputFilename, deduplicateNames, triggerDownload
4. App.tsx has Download All button with ZIP progress, beforeunload guard, hasDownloaded tracking
5. ImageCard.tsx has per-image download button for done images
6. fflate is in package.json dependencies
</verification>

<success_criteria>
- User can download all processed images as a ZIP with _nobg suffix filenames
- User can download individual processed images
- ZIP uses streaming fflate (ZipPassThrough, not zipSync) for bounded memory
- Browser warns before navigating away during processing or with undownloaded results
- Duplicate filenames are deduplicated in ZIP
- TypeScript compiles cleanly, production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-download-deploy/03-01-SUMMARY.md`
</output>
