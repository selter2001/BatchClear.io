---
phase: 02-batch-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/types.ts
  - src/lib/compositor.ts
  - src/lib/queue.ts
  - src/components/DropZone.tsx
  - src/components/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag-and-drop or click-to-browse up to 100 images at once"
    - "Unsupported file types are rejected with a clear error message"
    - "Max 2 images process concurrently; remaining wait in queue"
    - "Each image tracks its own status: idle -> queued -> processing -> done / error"
    - "Failed images can be retried individually without restarting the batch"
    - "Both transparent (PNG) and white-background (JPG) results are generated per image"
    - "HEIC files are converted at drop time before entering the queue"
    - "Blob URLs are revoked on image removal, retry, and batch clear"
  artifacts:
    - path: "src/lib/types.ts"
      provides: "ImageItem, BatchState, BatchAction, ImageStatus, BackgroundMode types"
      contains: "ImageStatus"
    - path: "src/lib/queue.ts"
      provides: "p-limit based concurrency queue (max 2)"
      contains: "pLimit"
    - path: "src/lib/compositor.ts"
      provides: "Extended compositor with white background support"
      contains: "white"
    - path: "src/components/DropZone.tsx"
      provides: "react-dropzone multi-file upload with validation"
      contains: "useDropzone"
    - path: "src/components/App.tsx"
      provides: "useReducer batch state, worker integration, queue orchestration"
      contains: "useReducer"
  key_links:
    - from: "src/components/DropZone.tsx"
      to: "src/components/App.tsx"
      via: "onFilesAccepted callback dispatches ADD_IMAGES"
      pattern: "ADD_IMAGES"
    - from: "src/components/App.tsx"
      to: "src/lib/queue.ts"
      via: "enqueue processing after ADD_IMAGES"
      pattern: "enqueueProcessing|limit"
    - from: "src/lib/queue.ts"
      to: "src/workers/inference.worker.ts"
      via: "postMessage with imageId for each queued image"
      pattern: "postMessage.*process"
    - from: "src/components/App.tsx"
      to: "src/lib/compositor.ts"
      via: "compositeFullResolution called on inference-complete"
      pattern: "compositeFullResolution"
    - from: "src/lib/compositor.ts"
      to: "src/components/App.tsx"
      via: "returns transparent + white Blobs, stored as Blob URLs in state"
      pattern: "resultUrl.*resultWhiteUrl"
---

<objective>
Batch upload infrastructure: multi-file drag-and-drop with react-dropzone, useReducer batch state machine, p-limit concurrency queue (max 2), compositor extension for white-background JPG output, HEIC conversion at drop time, and Blob URL lifecycle management.

Purpose: This plan builds the entire data/processing layer for batch background removal. Without this, Phase 2 UI components have nothing to render or control. All state management, file validation, queue orchestration, and processing logic lives here.

Output: A working (but visually minimal) batch processing pipeline -- drop 100 images, watch them queue and process 2 at a time, each producing both transparent PNG and white-background JPG results.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-batch-ui/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/lib/types.ts
@src/lib/compositor.ts
@src/components/App.tsx
@src/components/DropZone.tsx
@src/workers/inference.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Batch types, compositor extension, and concurrency queue</name>
  <files>
    package.json
    src/lib/types.ts
    src/lib/compositor.ts
    src/lib/queue.ts
  </files>
  <action>
1. Install dependencies:
   ```bash
   npm install react-dropzone p-limit
   ```

2. **Extend `src/lib/types.ts`** -- Keep ALL existing types (WorkerInMessage, WorkerOutMessage, ModelStatus, DownloadProgress) and ADD the batch types below them:

   ```typescript
   export type ImageStatus = "idle" | "queued" | "processing" | "done" | "error";
   export type BackgroundMode = "transparent" | "white";

   export interface ImageItem {
     id: string;
     file: File;               // Original file (or HEIC-converted JPEG)
     name: string;              // Original filename for display
     status: ImageStatus;
     error?: string;
     originalUrl: string;       // Blob URL for original preview
     resultUrl?: string;        // Blob URL for transparent PNG result
     resultWhiteUrl?: string;   // Blob URL for white-background JPG result
   }

   export interface BatchState {
     images: ImageItem[];
     backgroundMode: BackgroundMode;
   }

   export type BatchAction =
     | { type: "ADD_IMAGES"; items: ImageItem[] }  // Pre-built items (after HEIC conversion)
     | { type: "SET_QUEUED"; id: string }
     | { type: "SET_PROCESSING"; id: string }
     | { type: "SET_DONE"; id: string; resultUrl: string; resultWhiteUrl: string }
     | { type: "SET_ERROR"; id: string; error: string }
     | { type: "RETRY"; id: string }
     | { type: "REMOVE"; id: string }
     | { type: "SET_BACKGROUND_MODE"; mode: BackgroundMode }
     | { type: "CLEAR_ALL" };
   ```

   Note: ADD_IMAGES accepts pre-built ImageItem[] (not raw File[]) because HEIC conversion happens BEFORE dispatch. The items arrive with `status: "idle"` and `originalUrl` already created.

3. **Extend `src/lib/compositor.ts`** -- Add a `background` parameter to `compositeFullResolution`:

   - Add a third parameter: `background: "transparent" | "white" = "transparent"`
   - When `background === "transparent"`: existing logic unchanged, export as PNG
   - When `background === "white"`: after applying the mask, create one more OffscreenCanvas at origW x origH, fill it white (`#ffffff`), draw the masked output on top using `drawImage(outputCanvas, 0, 0)`, export as JPEG at quality 0.95, then shrink that canvas to 1x1 for cleanup
   - The transparent PNG path remains the default behavior

4. **Create `src/lib/queue.ts`** -- Concurrency queue using p-limit:

   ```typescript
   import pLimit from "p-limit";

   const limit = pLimit(2);

   export function enqueueProcessing(
     ids: string[],
     processOne: (id: string) => Promise<void>,
   ): void {
     for (const id of ids) {
       // Fire-and-forget: p-limit manages concurrency.
       // Errors are caught inside processOne (dispatched as SET_ERROR).
       void limit(() => processOne(id));
     }
   }

   export function getPendingCount(): number {
     return limit.pendingCount;
   }

   export function getActiveCount(): number {
     return limit.activeCount;
   }
   ```

   Keep it minimal. The queue just gates concurrency. All error handling and state updates happen in the processOne callback provided by App.tsx.
  </action>
  <verify>
    Run `npx tsc -b` -- zero errors. Confirm react-dropzone and p-limit are in package.json dependencies. Confirm `src/lib/queue.ts` exists. Confirm compositor.ts has `background` parameter.
  </verify>
  <done>
    - types.ts exports ImageItem, BatchState, BatchAction, ImageStatus, BackgroundMode alongside existing Worker types
    - compositor.ts accepts `background: "transparent" | "white"` parameter; transparent produces PNG (existing), white produces JPG with white fill
    - queue.ts exports enqueueProcessing that gates concurrent calls to max 2
    - react-dropzone and p-limit installed in package.json
    - TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-file DropZone and App.tsx batch refactor</name>
  <files>
    src/components/DropZone.tsx
    src/components/App.tsx
  </files>
  <action>
1. **Replace `src/components/DropZone.tsx`** with react-dropzone implementation:

   - Import `useDropzone` and `FileRejection` from `react-dropzone`
   - Accept prop format (object, NOT string):
     ```typescript
     const ACCEPT = {
       "image/png": [".png"],
       "image/jpeg": [".jpg", ".jpeg"],
       "image/webp": [".webp"],
       "image/heic": [".heic"],
       "image/heif": [".heif"],
     };
     ```
   - Props: `onFilesAccepted: (files: File[]) => void`, `onFilesRejected: (rejections: FileRejection[]) => void`, `disabled: boolean`, `imageCount: number` (current count, to enforce 100 max)
   - Configure useDropzone: `accept: ACCEPT`, `maxFiles: 100 - imageCount` (dynamic remaining), `multiple: true`, `disabled`, `onDropAccepted: onFilesAccepted`, `onDropRejected: onFilesRejected`
   - UI: Keep the existing visual style (dashed border, upload icon, browse button) but update text to "Drop up to 100 images here" and show current count when > 0. Add drag-active state styling.
   - Show rejection errors below the drop zone (file type errors, too-many-files errors). Use `rejection.errors[0].code` to distinguish `file-invalid-type` vs `too-many-files`. Clear errors after 5 seconds via setTimeout.
   - The drop zone should remain visible even when images are processing (so user can add more images to the batch).

2. **Refactor `src/components/App.tsx`** -- Major rewrite from single-image useState to batch useReducer:

   **Batch reducer:**
   - Create `batchReducer(state: BatchState, action: BatchAction): BatchState` inside App.tsx (or a separate file if it gets long, but inline is fine for now)
   - `ADD_IMAGES`: append items to `state.images`
   - `SET_QUEUED/SET_PROCESSING/SET_DONE/SET_ERROR`: find image by id, update status (and resultUrl/resultWhiteUrl for SET_DONE, error for SET_ERROR)
   - `RETRY`: find image by id, revoke old resultUrl and resultWhiteUrl if they exist, reset status to "queued", clear error
   - `REMOVE`: find image by id, revoke its originalUrl + resultUrl + resultWhiteUrl, filter it out
   - `CLEAR_ALL`: revoke ALL Blob URLs for ALL images, return empty state
   - `SET_BACKGROUND_MODE`: update `state.backgroundMode`
   - Initialize with `{ images: [], backgroundMode: "transparent" }`

   **HEIC conversion at drop time:**
   - Move `isHeicFile` and `convertHeicToJpeg` helpers from current App.tsx (keep them)
   - In the `handleFilesAccepted` callback: iterate files, convert any HEIC to JPEG (await all conversions), create ImageItem for each with `id: crypto.randomUUID()`, `status: "idle"`, `originalUrl: URL.createObjectURL(file)`, dispatch `ADD_IMAGES`

   **Queue orchestration:**
   - After dispatching ADD_IMAGES, call `enqueueProcessing(newIds, processOneImage)`
   - Before enqueuing, dispatch SET_QUEUED for each new image ID
   - `processOneImage(id: string)` function:
     1. Dispatch SET_PROCESSING
     2. Find image in stateRef.current.images by id (use a ref that mirrors state -- `useRef` updated in useEffect -- to avoid stale closures)
     3. Post `{ type: "process", imageId: id, imageData: image.file }` to worker
     4. Await response via a Promise that resolves/rejects from the worker message handler (create a Map<string, {resolve, reject}> pattern)
     5. On inference-complete: call `compositeFullResolution(file, maskData, "transparent")` and `compositeFullResolution(file, maskData, "white")` to get both Blobs
     6. Create Blob URLs for both results
     7. Dispatch SET_DONE with both URLs
     8. On inference-error: dispatch SET_ERROR

   **Worker message handler pattern:**
   - Create a `pendingInferences` ref: `useRef<Map<string, { resolve: Function, reject: Function }>>(new Map())`
   - In the worker onmessage handler:
     - `inference-complete`: resolve the pending promise for that imageId with maskData
     - `inference-error`: reject the pending promise for that imageId
     - Model progress/ready/error: keep existing handling for model status
   - In `processOneImage`: create a new Promise, store resolve/reject in pendingInferences map keyed by imageId, postMessage to worker, await the promise

   **Retry handler:**
   - `handleRetry(id: string)`: dispatch RETRY, then call `enqueueProcessing([id], processOneImage)`

   **Rejection handler:**
   - `handleFilesRejected`: collect error messages from FileRejection[], show them (can use a separate `rejectionErrors` state or pass to DropZone)

   **Cleanup on unmount:**
   - In the cleanup useEffect, revoke all Blob URLs from current state

   **Render (minimal for now -- 02-02 will add proper UI):**
   - Keep header (BatchClear.io title)
   - ModelProgress component (unchanged)
   - DropZone (always visible, passes imageCount)
   - Simple list of images showing: filename, status badge text, retry button for errors
   - Use a basic `<div>` list layout (NOT the final grid -- that's 02-02's job)
   - Show batch progress as text: "X of Y processed"

   **Important implementation details:**
   - Do NOT create multiple Workers. Reuse the single Worker from Phase 1.
   - The Worker already supports concurrent requests via imageId -- it can handle 2 simultaneous `process` messages.
   - Keep the `stateRef` pattern: `const stateRef = useRef(state)` updated via `useEffect(() => { stateRef.current = state })` -- this avoids stale closures in processOneImage.
  </action>
  <verify>
    Run `npx tsc -b` -- zero errors. Run `npm run dev`, open browser:
    1. Drop 5 JPG files -- all 5 should appear in the list
    2. Verify max 2 show "Processing" simultaneously, others show "Queued" / "Waiting"
    3. As processing completes, images transition to "Done"
    4. Drop a .txt file -- should be rejected with error message
    5. Try dropping 101 files -- should reject with too-many-files error
    6. If any image fails, verify retry button re-enqueues it
  </verify>
  <done>
    - DropZone accepts multiple files via react-dropzone with maxFiles=100, validates types, shows rejection errors
    - App.tsx uses useReducer with BatchState, dispatching ADD_IMAGES -> SET_QUEUED -> SET_PROCESSING -> SET_DONE/SET_ERROR
    - Processing queue runs max 2 concurrent through p-limit, remaining wait
    - Both transparent PNG and white-background JPG generated per image
    - HEIC files converted to JPEG at drop time (before queue)
    - Retry dispatches RETRY and re-enqueues through p-limit
    - Blob URLs revoked on REMOVE, CLEAR_ALL, RETRY (old results), and unmount
    - Minimal list UI shows status per image (proper grid UI deferred to 02-02)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npx tsc -b` passes with zero errors
2. `npm run dev` serves the app
3. Drop 10+ images: 2 process concurrently, rest queue, all eventually complete
4. Each completed image has both resultUrl and resultWhiteUrl in state (inspect via React DevTools or console.log)
5. Drop an unsupported file (.txt, .pdf): rejected with clear error
6. Drop files when already at 95 images: only 5 accepted, rest rejected as too-many
7. Force an error (e.g., drop a corrupt file): error state shown, retry button works
8. Memory: after processing and clearing all images, no dangling Blob URLs (check via Performance tab)
</verification>

<success_criteria>
- Batch processing of up to 100 images works end-to-end with max 2 concurrent
- Each image independently tracks status through its full lifecycle
- Both output formats (transparent PNG + white JPG) generated per image
- File validation rejects unsupported types with user-facing error messages
- Failed images can be retried individually
- No Blob URL memory leaks on remove/clear/retry
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-batch-ui/02-01-SUMMARY.md`
</output>
